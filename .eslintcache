[{"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\App.tsx":"1","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\CollisionSphere.ts":"2","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\constants.ts":"3","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\util.ts":"4","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ViewportHooks.tsx":"5","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\Effects.tsx":"6","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\ThreePointVis.tsx":"7","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\Stats.tsx":"8","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\DataList\\DataList.tsx":"9","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\PointInfo\\PointInfo.tsx":"10","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\LoadingOverlay\\LoadingOverlay.tsx":"11","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\Controls.tsx":"12","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\InstancedPoints.tsx":"13","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\VoxelInstancedPoints.tsx":"14","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\ClusterHulls.tsx":"15","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\Text.tsx":"16","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\index.tsx":"17"},{"size":20427,"mtime":1610877877701,"results":"18","hashOfConfig":"19"},{"size":1729,"mtime":1610877982584,"results":"20","hashOfConfig":"19"},{"size":2232,"mtime":1610877987120,"results":"21","hashOfConfig":"19"},{"size":251,"mtime":1610878015032,"results":"22","hashOfConfig":"19"},{"size":1084,"mtime":1610878019098,"results":"23","hashOfConfig":"19"},{"size":2307,"mtime":1610877952179,"results":"24","hashOfConfig":"19"},{"size":4651,"mtime":1610877841913,"results":"25","hashOfConfig":"19"},{"size":430,"mtime":1610877961401,"results":"26","hashOfConfig":"19"},{"size":4824,"mtime":1610877902822,"results":"27","hashOfConfig":"19"},{"size":1242,"mtime":1610877927466,"results":"28","hashOfConfig":"19"},{"size":438,"mtime":1610877923493,"results":"29","hashOfConfig":"19"},{"size":3893,"mtime":1610878076700,"results":"30","hashOfConfig":"19"},{"size":6661,"mtime":1610878076715,"results":"31","hashOfConfig":"19"},{"size":5578,"mtime":1610878076728,"results":"32","hashOfConfig":"19"},{"size":932,"mtime":1610877933255,"results":"33","hashOfConfig":"19"},{"size":2539,"mtime":1610877965317,"results":"34","hashOfConfig":"19"},{"size":255,"mtime":1610878004046,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"39"},"1osl008",{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"39"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"39"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"39"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"39"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\App.tsx",["76","77","78"],"import * as React from 'react';\nimport { useMemo } from 'react';\nimport './styles.scss';\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\nimport * as THREE from 'three';\nimport {\n  BoxBufferGeometry, Group, Mesh, MeshBasicMaterial, Object3D, Sphere, Vector3,\n} from 'three';\nimport useAxios from 'axios-hooks';\nimport { Camera, Canvas } from 'react-three-fiber';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport qs from 'query-string';\nimport { History, Location } from 'history';\nimport {\n  Tab, TabList, TabPanel, Tabs,\n} from 'react-tabs';\nimport { ThreePointVis } from './ThreePointVis/ThreePointVis';\nimport { PointInfo } from './PointInfo/PointInfo';\nimport { cleanTerm, DataList } from './DataList/DataList';\nimport { CollisionSphere } from './CollisionSphere';\nimport { Effects } from './ThreePointVis/Effects';\nimport { Stats } from './ThreePointVis/Stats';\nimport {\n  CLIP_SCALE_FACTOR,\n  dataSetList,\n  dataSets,\n  expandChar,\n  MAX_POINT_RES,\n  MAX_VIEW_DISTANCE,\n  MAX_VOXEL_RES,\n  MIN_VIEW_DISTANCE,\n  MIN_VOXEL_RES,\n  minimizeChar,\n  MOBILE_THRESHOLD_WIDTH,\n  POINT_RADIUS,\n} from './constants';\nimport { LoadingOverlay } from './LoadingOverlay/LoadingOverlay';\nimport { range } from './util';\nimport { useWindowSize } from './ViewportHooks';\n\nexport interface Point {\n  id: number;\n  subreddit: string;\n  x: number;\n  y: number;\n  z: number;\n  cluster: number;\n  percentNsfw: number;\n  include: boolean;\n}\n\nexport interface Cluster {\n  id: number;\n  obj: Mesh;\n}\n\nconst loader = new OBJLoader();\n\nconst getAutoVoxelResolution = (numberOfPoints: number) => Math.max(MIN_VOXEL_RES,\n  Math.min(MAX_VOXEL_RES,\n    Math.floor(Math.cbrt(numberOfPoints / 80))));\n\nconst getMesh = (group: Group | Object3D): Mesh => {\n  for (let i = 0; i < group.children.length; i++) {\n    const child = group.children[i];\n    if (child instanceof Mesh) {\n      return child;\n    }\n    if (child.children.length) {\n      return getMesh(child);\n    }\n  }\n  // return error mesh\n  const geometry = new BoxBufferGeometry(1, 1, 1);\n  const material = new MeshBasicMaterial({ color: 0xffff00 });\n  return new Mesh(geometry, material);\n};\n\nexport const pointCounts = [10000, 25000, 50000, 100000, 250000, 500000];\n\nfunction useQuery() {\n  return new URLSearchParams(useLocation().search);\n}\n\nconst setQueryParam = (key: string, value: string, history: History, location: Location) => {\n  const queryParams = qs.parse(location.search);\n  const newQueries = { ...queryParams, [key]: value };\n  history.push({ search: qs.stringify(newQueries) });\n};\n\nexport default function App() {\n  const query = useQuery();\n  const history = useHistory();\n  const location = useLocation();\n  const pointCount = parseInt(query.get('point_count') || '0', 10) || 25000;\n  const dataSet = query.get('data_set') || dataSets[Object.keys(dataSets)[0]];\n  const selection = (query.get('selection') || '').split(',') || [];\n  const { width, height } = useWindowSize();\n\n  const [redditData, setRedditData] = React.useState<Point[]>([]);\n  const [clusters, setClusters] = React.useState<Cluster[]>([]);\n  const [clusterCounts, setClusterCounts] = React.useState<number[]>([]);\n  const [clusterIndex, setClusterIndex] = React.useState<number>(3); // TODO remove hard coding\n  const [searchTerm, setSearchTerm] = React.useState('');\n  const [showControls, setShowControls] = React.useState(window.innerWidth > MOBILE_THRESHOLD_WIDTH);\n  const [showAdvancedControls, setShowAdvancedControls] = React.useState(false);\n  const [multiSelect, setMultiSelect] = React.useState(false);\n  const [pointResolution, setPointResolution] = React.useState(\n    Math.floor(Math.max(Math.min(4 + window.innerWidth / 320, MAX_POINT_RES * 0.75), 1)),\n  );\n  const [maxPercentNSFW, setMaxPercentNSFW] = React.useState(10);\n  const [usePostProcessing, setUsePostProcessing] = React.useState(window.innerWidth > MOBILE_THRESHOLD_WIDTH);\n  const [useAntiAliasing, setUseAntiAliasing] = React.useState(window.innerWidth > MOBILE_THRESHOLD_WIDTH);\n  const [resolutionScale, setResolutionScale] = React.useState(Math.ceil(window.devicePixelRatio / 2));\n  const [usePerPointLighting, setUsePerPointLighting] = React.useState(window.innerWidth > MOBILE_THRESHOLD_WIDTH);\n  const [showClusterHulls, setShowClusterHulls] = React.useState(false);\n  const [voxelResolution, setVoxelResolution] = React.useState(getAutoVoxelResolution(pointCount));\n  const [debugVoxels, setDebugVoxels] = React.useState(false);\n  const [viewDistance, setViewDistance] = React.useState(\n    Math.min(window.innerWidth * window.innerHeight * CLIP_SCALE_FACTOR, MAX_VIEW_DISTANCE),\n  );\n  const [camera, setCamera] = React.useState<Camera>();\n  const [dataList, setDataList] = React.useState<string[]>([]);\n\n  const selectedPoints = useMemo(() => redditData.filter((point) => selection.includes(point.subreddit)),\n    [selection, redditData]);\n\n  const [{ data, loading, error }] = useAxios(\n    `https://redditexplorer.com/GetData/dataset:${dataSet},n_points:${pointCount}`,\n  );\n\n  const setParam = (key: string, value: string) => setQueryParam(key, value, history, location);\n\n  React.useEffect(() => {\n    const newRedditData: Point[] = data\n      ? data.data.map((point: any, index: number) => ({\n        id: index,\n        subreddit: point.subreddit,\n        x: point.x,\n        y: point.y,\n        z: point.z,\n        cluster: point.cluster[clusterIndex],\n        percentNsfw: point.percentNsfw,\n        include: point.percentNsfw <= maxPercentNSFW,\n      }))\n      : [];\n\n    const newClusterCounts = data ? data.clusterCounts : [];\n    const clusterCount = newClusterCounts[clusterIndex];\n\n    const newClusters = data\n      ? data.clusters[clusterCount].map(\n        (cluster: any): Cluster => ({\n          id: cluster.id,\n          obj: getMesh(loader.parse(cluster.obj)),\n        }),\n      )\n      : [];\n\n    if (newRedditData && newRedditData.length) {\n      setRedditData(newRedditData);\n      setDataList(newRedditData.filter((point) => point.include).map((point) => point.subreddit));\n    }\n    if (newClusters && newClusters.length) {\n      setClusters(newClusters);\n    }\n    setClusterCounts(newClusterCounts);\n  }, [maxPercentNSFW, data, clusterIndex]);\n\n  React.useEffect(() => {\n    const clusterCount = clusterCounts[clusterIndex];\n\n    const newClusters = data && clusterCount\n      ? data.clusters[clusterCount].map(\n        (cluster: any): Cluster => ({\n          id: cluster.id,\n          obj: getMesh(loader.parse(cluster.obj)),\n        }),\n      )\n      : [];\n    setClusters(newClusters);\n  }, [clusterIndex, clusterCounts, data]);\n\n  React.useEffect(() => {\n    setVoxelResolution(getAutoVoxelResolution(pointCount));\n  }, [pointCount]);\n\n  React.useEffect(() => {\n    if (camera) {\n      camera.far = viewDistance;\n      camera.updateProjectionMatrix();\n    }\n  }, [viewDistance, camera]);\n\n  const selectOrDeselectPoint = (index: number, isMultiSelect: boolean) => {\n    const selectedIds = selectedPoints.map((point) => point.id);\n    if (isMultiSelect) {\n      if (!selectedIds.includes(index)) {\n        const newSelection = [...selection];\n        newSelection.push(redditData[index].subreddit);\n        setParam('selection', newSelection.join(','));\n      } else {\n        const newSelectedPoints = [...selectedPoints].filter((point) => point.id !== index);\n        setParam('selection', newSelectedPoints.map((p) => p.subreddit).join(','));\n      }\n    } else if (selectedIds.length !== 1 || selectedIds[0] !== index) {\n      setParam('selection', redditData[index].subreddit);\n    } else {\n      setParam('selection', '');\n    }\n  };\n\n  const search = (term: string) => {\n    redditData.forEach((point) => {\n      if (point.include && point.subreddit.toLowerCase() === cleanTerm(term)) {\n        selectOrDeselectPoint(point.id, multiSelect);\n      }\n    });\n  };\n\n  const mouseDownRef = React.useRef([0, 0]);\n  const raycaster = new THREE.Raycaster();\n  raycaster.params = { Points: { threshold: POINT_RADIUS * 0.01 } };\n\n  const collisionGeometry = useMemo(() => redditData.filter((point) => point.include)\n    .map((point) => {\n      const sphere = new Sphere(new Vector3(point.x, point.y, point.z), POINT_RADIUS);\n      return new CollisionSphere(sphere, point.id);\n    }), [redditData]);\n\n  const handlePointerDown = (event: React.PointerEvent<HTMLDivElement>) => {\n    mouseDownRef.current[0] = event.clientX;\n    mouseDownRef.current[1] = event.clientY;\n  };\n\n  const handleClick = (event: React.PointerEvent<HTMLDivElement>) => {\n    const { clientX, clientY } = event;\n    const downDistance = Math.sqrt(\n      mouseDownRef.current[0] - clientX ** 2\n      + mouseDownRef.current[1] - clientY ** 2,\n    );\n\n    // skip click if we dragged more than 5px distance\n    if (downDistance > 5) {\n      event.stopPropagation();\n      return;\n    }\n    if (camera) {\n      const mouse = {\n        x: (event.clientX / window.innerWidth) * 2 - 1,\n        y: -(event.clientY / window.innerHeight) * 2 + 1,\n      };\n\n      raycaster.setFromCamera(mouse, camera);\n      const intersects = raycaster.intersectObjects(collisionGeometry);\n\n      if (intersects.length > 0) {\n        const intersected = intersects[0].object as CollisionSphere;\n        const clickedId = intersected.index;\n        selectOrDeselectPoint(clickedId, multiSelect || event.ctrlKey);\n      }\n    }\n  };\n\n  const resolutionScales = useMemo(() => range(0.5, window.devicePixelRatio, 0.5), [window.devicePixelRatio]);\n\n  const resolutionOptions = useMemo(() => resolutionScales.map((scaleFactor, index) => {\n    const suffix = `${scaleFactor * width}x${scaleFactor * height} ${index === resolutionScales.length - 1\n      ? '(native)'\n      : ''}`;\n    return (\n      <option\n        value={scaleFactor}\n        key={scaleFactor}\n      >\n        {`${scaleFactor}x -- ${suffix}`}\n      </option>\n    );\n  }), [width, height]);\n\n  return (\n    <div className=\"App\">\n      {loading && <LoadingOverlay message=\"Loading dollops of dope data\" />}\n      {error && <span className=\"error-message\">{error.message}</span>}\n      {!loading && !error && redditData && redditData.length && (\n      <div className=\"vis-container\" key={`${redditData.length} ${resolutionScale}`}>\n        <Canvas\n          concurrent\n          gl={{ antialias: false }}\n          pixelRatio={resolutionScale}\n          camera={{ position: [0, 0, 600], far: viewDistance }}\n          onCreated={(gl) => setCamera(gl.camera)}\n          onPointerDown={handlePointerDown}\n          onPointerUp={handleClick}\n        >\n          <Stats />\n          {(usePostProcessing || useAntiAliasing)\n                && <Effects useAA={useAntiAliasing} useUnrealBloom={usePostProcessing} />}\n          <ThreePointVis\n            data={redditData}\n            clusters={showClusterHulls ? clusters : []}\n            selectedPoints={selectedPoints}\n            onSelect={selectOrDeselectPoint}\n            pointResolution={pointResolution}\n            voxelResolution={voxelResolution}\n            debugVoxels={debugVoxels}\n            usePerPointLighting={usePerPointLighting}\n          />\n          )\n        </Canvas>\n      </div>\n      )}\n      <div className=\"controls\">\n        <div className=\"controls-title-bar\">\n          <h1 className=\"title\">Reddit Explorer</h1>\n          <button\n            type=\"button\"\n            className=\"minimize-controls-button\"\n            onClick={() => setShowControls(!showControls)}\n          >\n            {showControls ? minimizeChar : expandChar}\n          </button>\n        </div>\n        {showControls && (\n          <Tabs>\n            <TabList>\n              <Tab>Explore</Tab>\n              <Tab>Performance</Tab>\n              <Tab>About</Tab>\n            </TabList>\n\n            <TabPanel className=\"tab-panel explore-panel\">\n              <div className=\"search-section\">\n                <DataList\n                  values={dataList.filter(((value) => value.toLowerCase().includes(cleanTerm(searchTerm))))}\n                  id=\"subreddits\"\n                  onSelect={(value) => search(value)}\n                  onChange={(value) => setSearchTerm(value)}\n                />\n                <button type=\"button\" onClick={() => search(searchTerm)}>Search</button>\n              </div>\n              {!loading && data && selectedPoints.length !== 0 && (\n                <>\n                  <div className=\"selection-header\">\n                    <h3>Selection</h3>\n                    <button\n                      type=\"button\"\n                      onClick={() => setParam('selection', '')}\n                    >\n                      Clear\n                    </button>\n                  </div>\n                  <div className=\"selected-points-info\">\n                    {selectedPoints.map((point) => <PointInfo key={point.id} point={point} />)}\n                  </div>\n                </>\n              )}\n              <label htmlFor=\"multiSelect\">\n                Multi Select:\n              </label>\n              <input\n                id=\"multiSelect\"\n                type=\"checkbox\"\n                checked={multiSelect}\n                onChange={(event) => setMultiSelect(event.target.checked)}\n              />\n              <br />\n              <br />\n              <label htmlFor=\"nsfwSlider\">\n                {' '}\n                Max % NSFW Threads:\n                {' '}\n                {maxPercentNSFW}\n              </label>\n              <input\n                id=\"nsfwSlider\"\n                type=\"range\"\n                min={0}\n                max={100}\n                step={0.1}\n                value={maxPercentNSFW}\n                onChange={(event) => {\n                  setMaxPercentNSFW(+event.target.value);\n                  selectedPoints.filter((point) => point.percentNsfw < +event.target.value);\n                  setParam('selection', selectedPoints.map((p) => p.subreddit).join(','));\n                  // }\n                }}\n              />\n              <div>\n                <label htmlFor=\"pointCount\"># Points: </label>\n                <select\n                  name=\"pointCount\"\n                  id=\"pointCount\"\n                  onChange={(event) => {\n                    // setSelectedIds([]);\n                    setParam('point_count', event.target.value);\n                  }}\n                  value={pointCount}\n                >\n                  {pointCounts.map((pc) => <option value={pc} key={pc}>{pc}</option>)}\n                </select>\n              </div>\n              <div>\n                <label htmlFor=\"numClusters\"># Clusters: </label>\n                <select\n                  name=\"numClusters\"\n                  id=\"numClusters\"\n                  onChange={(event) => setClusterIndex(clusterCounts.indexOf(+event.target.value))}\n                  value={clusterCounts[clusterIndex]}\n                >\n                  {clusterCounts.map(\n                    (clusterCount) => <option value={clusterCount} key={clusterCount}>{clusterCount}</option>,\n                  )}\n                </select>\n              </div>\n              <div>\n                <label htmlFor=\"dataSet\">Data Set: </label>\n                <select\n                  name=\"dataSet\"\n                  id=\"dataSet\"\n                  onChange={(event) => setParam('data_set', dataSets[event.target.value as keyof dataSetList])}\n                  value={dataSets[dataSet]}\n                >\n                  {Object.keys(dataSets).map((ds) => <option value={ds} key={ds}>{ds}</option>)}\n                </select>\n              </div>\n              <br />\n              <label htmlFor=\"showClusterHulls\">\n                Show Cluster Hulls:\n              </label>\n              <input\n                id=\"showClusterHulls\"\n                type=\"checkbox\"\n                checked={showClusterHulls}\n                onChange={(event) => setShowClusterHulls(event.target.checked)}\n              />\n            </TabPanel>\n\n            <TabPanel className=\"tab-panel performance-panel\">\n              <label htmlFor=\"usePostProcessing\">\n                Enable Post FX:\n              </label>\n              <input\n                id=\"usePostProcessing\"\n                type=\"checkbox\"\n                checked={usePostProcessing}\n                onChange={(event) => setUsePostProcessing(event.target.checked)}\n              />\n              <br />\n              <label htmlFor=\"useAntiAliasing\">\n                Anti-aliasing (FXAA):\n              </label>\n              <input\n                id=\"useAntiAliasing\"\n                type=\"checkbox\"\n                checked={useAntiAliasing}\n                onChange={(event) => setUseAntiAliasing(event.target.checked)}\n              />\n              <br />\n              <label htmlFor=\"usePerPointLighting\">\n                Per Point Lighting:\n              </label>\n              <input\n                id=\"usePerPointLighting\"\n                type=\"checkbox\"\n                checked={usePerPointLighting}\n                onChange={(event) => setUsePerPointLighting(event.target.checked)}\n              />\n              <br />\n              <label htmlFor=\"resolutionSlider\">\n                {' '}\n                Point Resolution:\n                {' '}\n                {pointResolution}\n              </label>\n              <input\n                id=\"resolutionSlider\"\n                type=\"range\"\n                min=\"1\"\n                max={MAX_POINT_RES}\n                value={pointResolution}\n                onChange={(event) => setPointResolution(+event.target.value)}\n                step=\"1\"\n              />\n              <br />\n              <label htmlFor=\"viewDistance\">\n                {' '}\n                View Distance:\n                {' '}\n                {viewDistance}\n              </label>\n              <input\n                id=\"viewDistance\"\n                type=\"range\"\n                min={MIN_VIEW_DISTANCE}\n                max={MAX_VIEW_DISTANCE}\n                value={viewDistance}\n                onChange={(event) => setViewDistance(+event.target.value)}\n                step=\"1\"\n              />\n              <div className=\"resolution-scale-section\">\n                <label htmlFor=\"pixelResolutionMultiplier\">\n                  Resolution Scale:&nbsp;\n                </label>\n                <select\n                  name=\"pixelResolutionMultiplier\"\n                  id=\"pixelResolutionMultiplier\"\n                  onChange={(event) => setResolutionScale(+event.target.value)}\n                  value={resolutionScale}\n                >\n                  {resolutionOptions}\n                </select>\n              </div>\n              <div className=\"advanced-settings-title-bar\">\n                <h4>Advanced: </h4>\n                <button\n                  type=\"button\"\n                  className=\"minimize-controls-button\"\n                  onClick={() => setShowAdvancedControls(!showAdvancedControls)}\n                >\n                  {showAdvancedControls ? minimizeChar : expandChar}\n                </button>\n              </div>\n              {showAdvancedControls\n                  && (\n                  <>\n                    <label htmlFor=\"voxelResSlider\">\n                      {' '}\n                      Voxel Resolution:\n                      {' '}\n                      {voxelResolution}\n                    </label>\n                    <input\n                      id=\"voxelResSlider\"\n                      type=\"range\"\n                      min={1}\n                      max={MAX_VOXEL_RES}\n                      value={voxelResolution}\n                      onChange={(event) => setVoxelResolution(+event.target.value)}\n                      step=\"1\"\n                    />\n                    <br />\n                    <label htmlFor=\"debugVoxels\">\n                      Show Voxel Debug:\n                    </label>\n                    <input\n                      id=\"debugVoxels\"\n                      type=\"checkbox\"\n                      checked={debugVoxels}\n                      onChange={(event) => setDebugVoxels(event.target.checked)}\n                    />\n                  </>\n                  )}\n            </TabPanel>\n\n            <TabPanel className=\"tab-panel about-panel\">\n              <h4>Created By:</h4>\n              <div>Data Science: Tyler Nellesen</div>\n              <div>Application: John Morone</div>\n            </TabPanel>\n          </Tabs>\n        )}\n      </div>\n    </div>\n  );\n}\n",["79","80","81","82","83","84","85"],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\CollisionSphere.ts",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\constants.ts",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\util.ts",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ViewportHooks.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\Effects.tsx",["86"],"import React, { useRef, useEffect, useMemo } from 'react';\nimport * as THREE from 'three';\nimport { extend, useThree, useFrame } from 'react-three-fiber';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';\nimport { BloomPass } from 'three/examples/jsm/postprocessing/BloomPass.js';\nimport { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader';\n\nextend({\n  EffectComposer, ShaderPass, RenderPass, UnrealBloomPass, BloomPass,\n});\n\ninterface EffectsProps {\n  useAA?: boolean;\n  useStandardBloom?: boolean;\n  useUnrealBloom?: boolean;\n}\n\nexport function Effects(props: EffectsProps) {\n  const composer = useRef<EffectComposer>();\n  const {\n    scene, gl, size, camera,\n  } = useThree();\n  const aspectScalar = 8;\n  const aspect = useMemo(() => new THREE.Vector2(size.width / aspectScalar, size.height / aspectScalar), [\n    size,\n  ]);\n  const { useAA, useStandardBloom, useUnrealBloom } = props;\n\n  useEffect(() => composer.current!.setSize(size.width, size.height), [\n    size,\n  ]);\n  useFrame(() => (composer.current ? composer.current.render() : null), 1);\n\n  const unrealBloom = {\n    resolution: aspect,\n    strength: 0.3,\n    radius: 0.02,\n    threshold: 0.19,\n  };\n\n  const bloom = {\n    strength: 1,\n    kernelSize: 25,\n    sigma: 4,\n    targetResolution: 256,\n  };\n\n  return (\n    <effectComposer ref={composer} args={[gl]}>\n      <renderPass attachArray=\"passes\" scene={scene} camera={camera} />\n      { useUnrealBloom && (\n      <unrealBloomPass\n        attachArray=\"passes\"\n        args={[unrealBloom.resolution, unrealBloom.strength, unrealBloom.radius, unrealBloom.threshold]}\n      />\n      ) }\n      { useStandardBloom && (\n      <bloomPass\n        attachArray=\"passes\"\n        args={[bloom.strength, bloom.kernelSize, bloom.sigma, bloom.targetResolution]}\n      />\n      ) }\n      { useAA && (\n      <shaderPass\n        attachArray=\"passes\"\n        args={[FXAAShader]}\n        material-uniforms-resolution-value={[1 / size.width, 1 / size.height]}\n        renderToScreen\n      />\n      ) }\n    </effectComposer>\n  );\n}\n","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\ThreePointVis.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\Stats.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\DataList\\DataList.tsx",["87","88","89","90","91","92"],"// Based on: https://medium.com/@leofabrikant/react-autocomplete-with-react-virtualized-to-handle-massive-search-results-7865a8786972\nimport * as React from 'react';\nimport { areEqual, FixedSizeList as List } from 'react-window';\nimport './DataList.scss';\nimport { memo, useRef } from 'react';\n\nexport interface DataListProps {\n  values: string[];\n  id: string;\n  onSelect?: (\n    selected: string\n  ) => void;\n  onChange?: (\n    selected: string\n  ) => void;\n}\n\nexport const cleanTerm = (term: string) => term.toLowerCase().replace(/\\s+/g, '');\n\nconst itemHeight = 30;\n\nexport const DataList = memo((props: DataListProps) => {\n  const {\n    values, id, onChange, onSelect,\n  } = props;\n\n  const [activeIndex, setActiveIndex] = React.useState<number | null>(null);\n  const [lastHoverIndex, setLastHoverIndex] = React.useState(0);\n  const [showMenu, setShowMenu] = React.useState(false);\n  const [mouseSelect, setMouseSelect] = React.useState(false);\n  const [searchTerm, setSearchTerm] = React.useState('');\n\n  const listRef = useRef<List>(null);\n  const containerRef = useRef<HTMLElement | null>(null);\n\n  React.useEffect(() => {\n    if (containerRef.current) {\n      containerRef?.current?.setAttribute('tabIndex', '0');\n    }\n  }, [containerRef]);\n\n  // @ts-ignore\n  // eslint-disable-next-line react/prop-types\n  const Row = memo(({ data, index, style }) => {\n    // Data passed to List as \"itemData\" is available as props.data\n    const item = data[index];\n\n    return (\n      // eslint-disable-next-line max-len\n      // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/mouse-events-have-key-events,jsx-a11y/no-static-element-interactions\n      <div\n        className=\"data-list-item\"\n        onMouseOver={() => {\n          if (lastHoverIndex !== index && mouseSelect) {\n            setActiveIndex(index);\n            setLastHoverIndex(index);\n          }\n        }}\n        onMouseMove={() => setMouseSelect(true)}\n        style={{\n          ...style,\n          backgroundColor: index === activeIndex ? '#0b195e' : '#111111',\n          verticalAlign: 'center',\n        }}\n        onClick={() => {\n          setShowMenu(false);\n          setActiveIndex(null);\n          onSelect && onSelect(values[index]);\n        }}\n      >\n        {item}\n      </div>\n    );\n  }, areEqual);\n\n  React.useEffect(() => {\n    if (activeIndex !== null) {\n      listRef.current?.scrollToItem(activeIndex);\n    }\n  });\n\n  return (\n    // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    <div\n      className=\"data-list\"\n      onBlur={(e) => {\n        if (containerRef?.current?.contains(e.relatedTarget as Node)) {\n          setShowMenu(false);\n          setActiveIndex(null);\n        }\n      }}\n      onKeyDown={(e) => {\n        const listLength = values.length;\n        // e.preventDefault();\n        e.stopPropagation();\n        if (e.keyCode === 13) {\n          if (activeIndex) {\n            const value = values[activeIndex];\n            onSelect && value && onSelect(value);\n            setShowMenu(false);\n            setActiveIndex(null);\n          } else {\n            onSelect && onSelect(searchTerm);\n          }\n        } else {\n          if (!showMenu) {\n            setShowMenu(true);\n          }\n          if (e.keyCode === 38) {\n            if (activeIndex === null) {\n              setActiveIndex(listLength - 1);\n            } else {\n              setMouseSelect(false);\n              const newActiveIndex = activeIndex - 1;\n              setActiveIndex(newActiveIndex >= 0 ? newActiveIndex : listLength - 1);\n            }\n          } else if (e.keyCode === 40) {\n            if (activeIndex === null) {\n              setActiveIndex(0);\n            } else {\n              setMouseSelect(false);\n              const newActiveIndex = activeIndex + 1;\n              setActiveIndex(newActiveIndex < listLength ? newActiveIndex : 0);\n            }\n          } else {\n            setActiveIndex(null);\n          }\n        }\n      }}\n    >\n      {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n      <div className=\"data-list-input\" onClick={() => setShowMenu(true)}>\n        <input\n          type=\"text\"\n          id={id}\n          list=\"subreddits\"\n          onChange={(e) => {\n            setSearchTerm(e.target.value);\n            if (onChange) {\n              onChange(e.target.value);\n            }\n          }}\n        />\n      </div>\n      {showMenu\n        && (\n        <List\n          ref={listRef}\n          outerRef={containerRef}\n          width=\"100%\"\n          height={190}\n          key={id}\n          style={{ position: 'absolute' }}\n          itemCount={values.length}\n          itemData={values}\n          itemSize={itemHeight}\n        >\n          {Row}\n        </List>\n        )}\n    </div>\n  );\n});\n","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\PointInfo\\PointInfo.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\LoadingOverlay\\LoadingOverlay.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\Controls.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\InstancedPoints.tsx",["93","94"],"import * as React from 'react';\nimport * as THREE from 'three';\nimport {\n  MouseEvent, useThree, useFrame, Camera,\n} from 'react-three-fiber';\nimport {\n  Frustum, Matrix4, Vector3, InstancedBufferAttribute,\n} from 'three';\nimport { MutableRefObject, useEffect, useState } from 'react';\nimport { SelectedIds, SelectedPoints, SelectHandler } from './ThreePointVis';\nimport { Point } from '../App';\nimport { SCALE_FACTOR, clusterColors, POINT_RADIUS } from '../constants';\n\ninterface InstancedPointsProps {\n  data: Point[];\n  selectedPoints: SelectedPoints;\n  onSelect: SelectHandler;\n  enableCulling?: boolean;\n  pointSegments: number;\n}\n\n// re-use for instance computations\nconst scratchColor = new THREE.Color();\nconst scratchObject3D = new THREE.Object3D();\nconst scratchSphere = new THREE.Sphere();\nconst scratchPos = new Vector3(0, 0, 0);\nconst frustum = new Frustum();\nconst projScreenMatrix = new Matrix4();\n\nconst SELECTED_COLOR = '#6f6';\n\nconst updateColors = (\n  data: Point[],\n  selectedIds: SelectedIds,\n  pointIndexToId: number[],\n  maxCount: number,\n  colorArray: Float32Array,\n  colorAttrib: MutableRefObject<InstancedBufferAttribute | undefined>,\n) => {\n  for (let i = 0; i < maxCount; ++i) {\n    const point = data[pointIndexToId[i]];\n    scratchColor.set(\n      selectedIds.includes(point.id) ? SELECTED_COLOR : clusterColors[point.cluster],\n    );\n    scratchColor.toArray(colorArray, i * 3);\n\n    if (colorAttrib.current) {\n      // eslint-disable-next-line no-param-reassign\n      colorAttrib.current.needsUpdate = true;\n    }\n  }\n};\n\nfunction updateInstancedMeshMatrices(\n  mesh: THREE.InstancedMesh,\n  data: Point[],\n  maxPoints: number,\n  enableCulling: boolean,\n  camera: Camera,\n  pointIndexToId: number[],\n  colorArray: Float32Array,\n  colorAttrib: MutableRefObject<InstancedBufferAttribute | undefined>,\n  selectedIds: SelectedIds,\n): number {\n  let visibleInstanceCount = 0;\n  if (mesh) {\n    for (let i = 0; i < maxPoints; ++i) {\n      const { x } = data[i];\n      const { y } = data[i];\n      const { z } = data[i];\n\n      projScreenMatrix.multiplyMatrices(\n        camera.projectionMatrix,\n        camera.matrixWorldInverse,\n      );\n      frustum.setFromProjectionMatrix(projScreenMatrix);\n\n      scratchPos.set(x, y, z);\n\n      scratchSphere.set(scratchPos, POINT_RADIUS);\n\n      if (\n        (!frustum.intersectsSphere(scratchSphere) && enableCulling)\n        || !data[i].include\n      ) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      scratchObject3D.position.set(x, y, z);\n      scratchObject3D.updateMatrix();\n      mesh.setMatrixAt(visibleInstanceCount, scratchObject3D.matrix);\n      // eslint-disable-next-line no-param-reassign\n      pointIndexToId[visibleInstanceCount] = data[i].id;\n      visibleInstanceCount++;\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    mesh.count = visibleInstanceCount;\n    // eslint-disable-next-line no-param-reassign\n    mesh.instanceMatrix.needsUpdate = true;\n\n    updateColors(\n      data,\n      selectedIds,\n      pointIndexToId,\n      visibleInstanceCount,\n      colorArray,\n      colorAttrib,\n    );\n  }\n  return visibleInstanceCount;\n}\n\nconst useMousePointInteraction = (\n  onSelect: SelectHandler,\n  pointIndexToId: number[],\n) => {\n  // track mousedown position to skip click handlers on drags\n  const mouseDownRef = React.useRef([0, 0]);\n  const handlePointerDown = (event: MouseEvent) => {\n    mouseDownRef.current[0] = event.clientX;\n    mouseDownRef.current[1] = event.clientY;\n  };\n\n  const handleClick = (event: MouseEvent) => {\n    const { instanceId, clientX, clientY } = event;\n    const downDistance = Math.sqrt(\n      mouseDownRef.current[0] - clientX ** 2\n        + mouseDownRef.current[1] - clientY ** 2,\n    );\n\n    // skip click if we dragged more than 5px distance\n    if (downDistance > 5) {\n      event.stopPropagation();\n      return;\n    }\n\n    const id = instanceId !== undefined ? pointIndexToId[instanceId] : -1;\n\n    onSelect(id, event.ctrlKey);\n  };\n\n  return { handlePointerDown, handleClick };\n};\n\nexport const InstancedPoints = (props: InstancedPointsProps) => {\n  const {\n    data, selectedPoints, onSelect, enableCulling, pointSegments,\n  } = props;\n  const pointIndexToId = data.map((point) => point.id);\n\n  const meshRef = React.useRef<THREE.InstancedMesh>();\n  const [mesh, setMesh] = useState();\n  useEffect(() => setMesh(meshRef.current), [data]);\n\n  const { camera } = useThree();\n\n  const numPoints = data.length;\n\n  const colorAttrib = React.useRef<THREE.InstancedBufferAttribute>();\n  const colorArray = React.useMemo(() => new Float32Array(numPoints * 3), [\n    numPoints,\n  ]);\n\n  useFrame(() => {\n    if (mesh) {\n      updateInstancedMeshMatrices(\n        mesh,\n        data,\n        numPoints,\n        enableCulling || false,\n        camera,\n        pointIndexToId,\n        colorArray,\n        colorAttrib,\n        selectedPoints.map((point) => point.id),\n      );\n    }\n  });\n\n  const { handleClick, handlePointerDown } = useMousePointInteraction(\n    onSelect,\n    pointIndexToId,\n  );\n\n  const renderInstancedMesh = selectedPoints.map(\n    (point) => (\n      <group\n        position={[\n          point.x,\n          point.y,\n          point.z,\n        ]}\n      >\n        <pointLight\n          distance={19 * SCALE_FACTOR}\n          position={[0, 0, 0]}\n          intensity={2.5}\n          decay={30}\n          color={SELECTED_COLOR}\n        />\n        <pointLight\n          distance={10 * SCALE_FACTOR}\n          position={[0, 0, 0]}\n          intensity={1.5}\n          decay={1}\n          color={SELECTED_COLOR}\n        />\n      </group>\n    ),\n  );\n\n  return (\n    <>\n      <instancedMesh\n        ref={meshRef}\n        args={[\n            // TODO sort out the bugged typing here.\n            // Ref: https://spectrum.chat/react-three-fiber/general/instancedmesh-gone-on-rerender-in-typescript~35e4d145-517f-4b81-b0c7-ab89e02bd72f\n            (null as unknown) as THREE.BufferGeometry,\n            (null as unknown) as THREE.Material,\n            numPoints,\n        ]}\n        onPointerUp={handleClick}\n        onPointerDown={handlePointerDown}\n      >\n        <sphereBufferGeometry\n          attach=\"geometry\"\n          args={[POINT_RADIUS, pointSegments, pointSegments]}\n          key={pointSegments}\n        >\n          <instancedBufferAttribute\n            ref={colorAttrib}\n            attachObject={['attributes', 'color']}\n            args={[colorArray, 3]}\n          />\n        </sphereBufferGeometry>\n        <meshStandardMaterial attach=\"material\" vertexColors />\n      </instancedMesh>\n      {selectedPoints.length > 0 && (\n        renderInstancedMesh\n      )}\n    </>\n  );\n};\n","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\VoxelInstancedPoints.tsx",["95","96","97","98","99","100","101","102"],"import * as React from 'react';\nimport * as THREE from 'three';\nimport {\n  InstancedBufferAttribute, MeshLambertMaterial, Object3D, Vector3,\n} from 'three';\nimport { memo, useMemo } from 'react';\nimport { Point } from '../App';\nimport { clusterColors, POINT_RADIUS } from '../constants';\n\ninterface VoxelInstancedPointsProps {\n  data: Point[];\n  pointSegments: number;\n  voxelResolution: number;\n  debugVoxels?: boolean;\n}\n\nconst gridScale = 1001;\nconst scratchColor = new THREE.Color(0xff0000);\n\nconst updateColors = (\n  points: Point[],\n  colorArray: Float32Array,\n  colorAttrib: InstancedBufferAttribute,\n  voxelIndex?: number,\n) => {\n  for (let i = 0; i < points.length; ++i) {\n    const point = points[i];\n    scratchColor.set(\n      clusterColors[voxelIndex === undefined ? point.cluster : voxelIndex % clusterColors.length],\n    );\n    scratchColor.toArray(colorArray, i * 3);\n  }\n  if (colorAttrib) {\n    // eslint-disable-next-line no-param-reassign\n    colorAttrib.needsUpdate = true;\n  }\n};\n\nexport const VoxelInstancedPoints = memo((props: VoxelInstancedPointsProps) => {\n  const {\n    data, pointSegments, voxelResolution, debugVoxels,\n  } = props;\n\n  const [voxels, setVoxels] = React.useState<Point[][]>([]);\n\n  // re-use for instance computations\n  const meshRefs = React.useRef<THREE.InstancedMesh[]>([]);\n  const colorAttribs = React.useRef<THREE.InstancedBufferAttribute[]>([]);\n  const colorArrays: Float32Array[] = [];\n  for (let i = 0; i < voxels.length; i++) {\n    colorArrays[i] = new Float32Array(voxels[i].length * 3);\n  }\n\n  // Sort points into voxel grid when data or grid resolution changes\n  React.useEffect(() => {\n    // eslint-disable-next-line no-mixed-operators\n    const gridStep = gridScale * 2 / voxelResolution; // double grid scale to account for negative ranges\n    const numVoxels = voxelResolution ** 3;\n    const newVoxels: Point[][] = [];\n    for (let i = 0; i < numVoxels; i++) {\n      newVoxels.push([]);\n    }\n\n    // const newVoxels: Point[][] = new Array(Math.pow(voxelResolution, 3)).fill(new Array);\n    data.forEach((point) => {\n      if (point.include) {\n        // Shift into positive ranges\n        const x = point.x + gridScale;\n        const y = point.y + gridScale;\n        const z = point.z + gridScale;\n\n        const voxelIndex = Math.floor(x / gridStep)\n          + Math.floor(y / gridStep) * voxelResolution\n          + Math.floor(z / gridStep) * voxelResolution * voxelResolution;\n        newVoxels[voxelIndex].push(point);\n      }\n    });\n    setVoxels(newVoxels);\n  }, [data, voxelResolution]);\n\n  // re-use for instance computations\n  const scratchObject3D = useMemo(() => new Object3D(), []);\n  const sharedMaterial = useMemo(() => new MeshLambertMaterial({ vertexColors: true }), []);\n\n  React.useEffect(() => {\n    let numEmptyVoxels = 0;\n    for (let i = 0; i < voxels.length; ++i) {\n      const voxel = voxels[i];\n      if (voxel.length > 0) {\n        const mesh = meshRefs.current[i];\n        const points = voxel.map((p) => new Vector3(p.x, p.y, p.z));\n\n        if (mesh) {\n          mesh.matrixAutoUpdate = false; // TODO try for clusters\n          mesh.updateMatrix();\n          // set the transform matrix for each instance\n          for (let j = 0; j < points.length; ++j) {\n            const { x } = points[j];\n            const { y } = points[j];\n            const { z } = points[j];\n\n            scratchObject3D.position.set(x, y, z);\n            scratchObject3D.updateMatrix();\n            mesh.setMatrixAt(j, scratchObject3D.matrix);\n          }\n\n          mesh.geometry.boundingSphere = new THREE.Sphere().setFromPoints(points);\n          mesh.geometry.boundingSphere.radius = Math.max(mesh.geometry.boundingSphere.radius, POINT_RADIUS);\n          mesh.instanceMatrix.needsUpdate = true;\n          mesh.frustumCulled = true;\n          updateColors(\n            voxel,\n            colorArrays[i],\n            colorAttribs.current[i],\n            debugVoxels ? i : undefined,\n          );\n        }\n      } else {\n        numEmptyVoxels++;\n      }\n    }\n    console.log('Total Voxels: ', voxels.length);\n    console.log('Empty Voxels: ', numEmptyVoxels);\n    console.log('Percent Empty Voxels ', (numEmptyVoxels / voxels.length) * 100);\n  }, [voxels, scratchObject3D, colorArrays, debugVoxels]);\n\n  return (\n    <>\n      {voxels.map((voxel, index) => (voxel.length > 0\n        ? (\n          <instancedMesh\n            key={`${index} ${voxel.length}`}\n            ref={(mesh: THREE.InstancedMesh) => meshRefs.current[index] = mesh}\n            args={[\n                  // TODO sort out the bugged typing here.\n                  // Ref: https://spectrum.chat/react-three-fiber/general/instancedmesh-gone-on-rerender-in-typescript~35e4d145-517f-4b81-b0c7-ab89e02bd72f\n                  (null as unknown) as THREE.BufferGeometry,\n                  (null as unknown) as THREE.Material,\n                  voxel.length,\n            ]}\n            material={sharedMaterial}\n          >\n            <sphereBufferGeometry\n              attach=\"geometry\"\n              args={[POINT_RADIUS, pointSegments, pointSegments]}\n              key={pointSegments}\n            >\n              <instancedBufferAttribute\n                name={`color - voxel ${index}`}\n                ref={(colorAttrib: THREE.InstancedBufferAttribute) => colorAttribs.current[index] = colorAttrib}\n                attachObject={['attributes', 'color']}\n                args={[colorArrays[index], 3]}\n              />\n            </sphereBufferGeometry>\n          </instancedMesh>\n        )\n        : null))}\n      )\n    </>\n  );\n});\n","C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\ClusterHulls.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\ThreePointVis\\Text.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\reddit_app\\src\\index.tsx",[],{"ruleId":"103","severity":1,"message":"104","line":97,"column":9,"nodeType":"105","endLine":97,"endColumn":68},{"ruleId":"103","severity":1,"message":"106","line":265,"column":84,"nodeType":"107","endLine":265,"endColumn":109,"suggestions":"108"},{"ruleId":"103","severity":1,"message":"109","line":279,"column":7,"nodeType":"107","endLine":279,"endColumn":22,"suggestions":"110"},{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","replacedBy":"114"},{"ruleId":"115","replacedBy":"116"},{"ruleId":"117","replacedBy":"118"},{"ruleId":"119","replacedBy":"120"},{"ruleId":"121","replacedBy":"122"},{"ruleId":"123","replacedBy":"124"},{"ruleId":"125","severity":1,"message":"126","line":8,"column":27,"nodeType":"127","endLine":8,"endColumn":75},{"ruleId":"128","severity":1,"message":"129","line":68,"column":11,"nodeType":"130","messageId":"131","endLine":68,"endColumn":47},{"ruleId":"132","severity":1,"message":"129","line":68,"column":11,"nodeType":"130","messageId":"131","endLine":68,"endColumn":47},{"ruleId":"128","severity":1,"message":"129","line":99,"column":13,"nodeType":"130","messageId":"131","endLine":99,"endColumn":50},{"ruleId":"132","severity":1,"message":"129","line":99,"column":13,"nodeType":"130","messageId":"131","endLine":99,"endColumn":50},{"ruleId":"128","severity":1,"message":"129","line":103,"column":13,"nodeType":"130","messageId":"131","endLine":103,"endColumn":46},{"ruleId":"132","severity":1,"message":"129","line":103,"column":13,"nodeType":"130","messageId":"131","endLine":103,"endColumn":46},{"ruleId":"133","severity":1,"message":"134","line":214,"column":3,"nodeType":"135","messageId":"136","endLine":214,"endColumn":14},{"ruleId":"133","severity":1,"message":"134","line":215,"column":3,"nodeType":"135","messageId":"136","endLine":215,"endColumn":14},{"ruleId":"103","severity":1,"message":"137","line":49,"column":9,"nodeType":"105","endLine":49,"endColumn":41},{"ruleId":"133","severity":1,"message":"134","line":76,"column":11,"nodeType":"135","messageId":"136","endLine":76,"endColumn":22},{"ruleId":"133","severity":1,"message":"134","line":125,"column":5,"nodeType":"135","messageId":"136","endLine":125,"endColumn":16},{"ruleId":"133","severity":1,"message":"134","line":126,"column":5,"nodeType":"135","messageId":"136","endLine":126,"endColumn":16},{"ruleId":"133","severity":1,"message":"134","line":127,"column":5,"nodeType":"135","messageId":"136","endLine":127,"endColumn":16},{"ruleId":"138","severity":1,"message":"139","line":135,"column":18,"nodeType":"140","endLine":135,"endColumn":44},{"ruleId":"141","severity":1,"message":"142","line":136,"column":18,"nodeType":"143","messageId":"144","endLine":136,"endColumn":79},{"ruleId":"141","severity":1,"message":"142","line":153,"column":22,"nodeType":"143","messageId":"144","endLine":153,"endColumn":112},"react-hooks/exhaustive-deps","The 'selection' logical expression could make the dependencies of useMemo Hook (at line 126) change on every render. To fix this, wrap the initialization of 'selection' in its own useMemo() Hook.","VariableDeclarator","React Hook useMemo has an unnecessary dependency: 'window.devicePixelRatio'. Either exclude it or remove the dependency array. Outer scope values like 'window.devicePixelRatio' aren't valid dependencies because mutating them doesn't re-render the component.","ArrayExpression",["145"],"React Hook useMemo has a missing dependency: 'resolutionScales'. Either include it or remove the dependency array.",["146"],"jsx-a11y/label-has-for",[],"lines-around-directive",["147"],"no-spaced-func",["148"],"global-require",[],"no-buffer-constructor",[],"no-new-require",[],"no-path-concat",[],"import/extensions","Unexpected use of file extension \"js\" for \"three/examples/jsm/postprocessing/BloomPass.js\"","Literal","@typescript-eslint/no-unused-expressions","Expected an assignment or function call and instead saw an expression.","ExpressionStatement","unusedExpression","babel/no-unused-expressions","no-console","Unexpected console statement.","MemberExpression","unexpected","The 'colorArrays' array makes the dependencies of useEffect Hook (at line 128) change on every render. To fix this, wrap the initialization of 'colorArrays' in its own useMemo() Hook.","react/no-array-index-key","Do not use Array index in keys","TemplateLiteral","no-return-assign","Arrow function should not return assignment.","ArrowFunctionExpression","arrowAssignment",{"desc":"149","fix":"150"},{"desc":"151","fix":"152"},"padding-line-between-statements","func-call-spacing","Update the dependencies array to be: []",{"range":"153","text":"154"},"Update the dependencies array to be: [resolutionScales, width, height]",{"range":"155","text":"156"},[9437,9462],"[]",[9854,9869],"[resolutionScales, width, height]"]